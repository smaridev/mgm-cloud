import json
import time
from flask import escape

from google.cloud import firestore, exceptions
from pubnub.callbacks import SubscribeCallback
from pubnub.enums import PNReconnectionPolicy, PNStatusCategory
from pubnub.pnconfiguration import PNConfiguration
from pubnub.pubnub import PubNub

system_snap_list = ["iotgw-discovery","mosquitto","pubnub-agent","bluez","pi3","pi2-kernel"]
INSTALLED = "Installed"
INSTALLING = "Installing"
FAILED = "Failed"
DELETING = "Deleting"
DELETED = "Deleted"


class DataAccessLayer(object):
    def __init__(self, collection):
        self.db = firestore.Client()
        self.collection = collection
    
    def get(self,docid):
        users_ref = self.db.collection(self.collection).document(docid)
        doc = users_ref.get()
        doc_dict = {}
        doc_dict = doc.to_dict().copy()
        doc_dict["serial"] = doc.id
        print(u'{} => {}'.format(doc.id,doc_dict))
        return doc_dict

    
    def update(self,message,doc_id,field_name):
        users_ref = self.db.collection(self.collection)
        print("field:{}, tpid:{}".format(field_name,doc_id))
        users_ref.document(doc_id).set({field_name:message}, merge=True)


def get_pubnub():
    pnconfig = PNConfiguration()
    pnconfig.subscribe_key = 'sub-c-a57ab586-2e94-11e9-8208-aaa77ad184aa'
    pnconfig.publish_key = 'pub-c-395634b8-6b43-407a-bd80-e656f030d997'
    pnconfig.reconnect_policy = PNReconnectionPolicy.LINEAR
    pnconfig.uuid = 'mgmt_cloud_uuid'
    pubnub = PubNub(pnconfig)
    return pubnub


def save_to_firestore(collection,message,doc_id=None,field=None):
    db = firestore.Client()
    doc_ref = db.collection(collection)
    #run through the message to payload validators - TBD
    if field:
        print("field:{}, tpid:{}".format(field,doc_id))
        doc_ref.document(doc_id).set({field:message}, merge=True)
    elif doc_id:
        print("field:{}, tpid:{}".format(field,doc_id))
        doc_ref.document(doc_id).set(message,merge=True)
    else:
        print("autogenerated docid")
        doc_ref.document().set(message,merge=True)
    '''
    if doc_id:
        doc_ref.document(doc_id).set(message)
    else:
        doc_ref.set(message)
    '''
    return

def my_publish_callback(envelope, status):
    # Check whether request successfully completed or not
    if not status.is_error():
        # Message successfully published to specified channel.
        print("success status:{}".format(status))
    else:
        # Handle message publish error. Check 'category' property to find out possible issue
        # because of which request did fail.
        # Request can be resent using: [status retry];
        print("error status:{}".format(status.error))


def send_registration_ack(tpid):
    reg_ack_message = {}
    reg_ack_message["message"] = "dscmgr/registered"
    reg_ack_message["tpid"] = tpid
    reg_ack_message["timestamp"] = int(time.time())
    reg_ack_message["status"] = "Registered"
    pubnub = get_pubnub()
    #channel = reg_ack_message["message"].replace("/",".") 
    channel = reg_ack_message["message"]
    downstream_channel = "cloud_to_edge." + str(tpid) + "." + str(channel)
    print("downstream to pubnub channel: {}".format(downstream_channel))
    #pubnub.publish().channel(downstream_channel).message(reg_ack_message).sync()
    pubnub.publish().channel(downstream_channel).message(reg_ack_message).pn_async(my_publish_callback)
    print("after publish")

def get_bundle_from_tpid(tpid):
    db = firestore.Client()
    snaplist = []
    '''
    thingpoint_ref = db.collection('thingpoint_db').document(tpid)
    try:
        doc = thingpoint_ref.get()
        print('Document data: {}'.format(doc.to_dict()))
        bundle_name = doc.get('bundle_name', None)
        if bundle_name:
            bundle_ref = db.collection('bundle_db').document('rasberrypie') #rasberrypie is model, this needs thingpoint should send this as model
            try:
                bundle_doc = bundle_ref.get()
                return bundle_doc.get('snaplist')
            except exceptions.NotFound:
                print('[ERROR]: Entry for bundle_name:{} is not present'.format(bundle_name))

    except exceptions.NotFound:
        print('[ERROR]: Entry for tpid:{} is not present'.format(tpid))
    '''
    #everything is rasberry pie
    bundle_ref = db.collection('bundle_db').document('rasberrypie') #rasberrypie is model, this needs thingpoint should send this as model
    try:
        bundle_doc = bundle_ref.get()
        print(bundle_doc)
        snaplist = bundle_doc.get('snap_list')
        #snaplist.append(bundle_doc.get('snap_list'))
    except exceptions.NotFound:
        print('[ERROR]: Entry for model in bundle_db :{} is not present'.format("rasberrypie"))
    
    thingpoint_ref = db.collection('thingpoint_db').document(tpid)
    try:
        doc = thingpoint_ref.get()
        snaplist = snaplist + doc.get('user_snap_list')
        #snaplist.append(doc.get('user_snap_list'))
    except exceptions.NotFound:
        print('[ERROR]: Entry for model in bundle_db :{} is not present'.format("rasberrypie"))
    #print("snaplist:{}".format(snaplist))
    return snaplist

def send_pushsnap_req(tpid,action,user_snap=None):
    pushsnap_req = {}
    snap_list = []
    pushsnap_req["message"] = "dscmgr/pushsnapreq"
    pushsnap_req["tpid"] = tpid
    pushsnap_req["timestamp"] = int(time.time())
    pushsnap_req["action"] = action
    if user_snap:
        snap_list.append(user_snap)
    else:
        bundle_snap_list = get_bundle_from_tpid(tpid) 
        print("default bundle_snap_list: {}".format(bundle_snap_list))
        for snap in bundle_snap_list:
            snap_list.append(snap['name'])
        
    pushsnap_req['snaplist'] = snap_list
    #pushsnap_req['snaplist'] = ["hello", "hello-world"]

    pubnub = get_pubnub()
    #channel = pushsnap_req["message"].replace("/",".") 
    channel = pushsnap_req["message"]
    downstream_channel = "cloud_to_edge." + str(tpid) + "." + str(channel)
    print("downstream to pubnub channel: {}".format(downstream_channel))
    #pubnub.publish().channel(downstream_channel).message(reg_ack_message).sync()
    pubnub.publish().channel(downstream_channel).message(pushsnap_req).pn_async(my_publish_callback)
    print("after publish")


def registration_handler(message):
    #parse registration message and reply with registration ack message
    tpid = str(message['tpid'])
    print("tpid:{}".format(tpid))
    if tpid is None:
        print("ERROR tpid is None")
        return
    
    timestamp = message['timestamp']
    hostname = message['hostname']
    status = message['status']
    network_details = message.get("networkdetails", None)
    if network_details:
        mac = network_details[0]["mac"]
        print("tpid:{}, mac:{}".format(tpid,mac))
    else:
        mac = "NA"

    if status == "Registering":
        #update the thingpoint entry
        msg = {}
        msg['hostname'] = hostname
        msg['timestamp'] = timestamp
        msg['cid'] = message['cid']
        msg['mac'] = mac
        msg['conn_status'] = True
        msg[status] = status
        msg["bundle_name"] = ["default"]
        save_to_firestore('thingpoint_db',msg,tpid)
        send_registration_ack(tpid)
    else:
        print("[DEBUG] received registration from tpid:{} with status:{}".format(tpid,status))
    return
    

def snaplist_handler(message):
    #parse registration message and reply Pushsnapreg message
    print("starting snaplist_handler")
    tpid = message['tpid']
    timestamp = message['timestamp']
    hostname = message['hostname']
    snaplist = message['snaplist']
    print("snaplist: {}".format(snaplist))
    msg_system = []
    msg_user = []
    for snap in snaplist:
        snap_dict = {}
        snap_dict['id'] = snap['id']
        snap_dict['installed-size'] = snap['installed-size']
        snap_dict['type'] = snap['type']
        snap_dict['version'] = snap['version']
        snap_dict['channel'] = snap['channel']
        snap_dict['revision'] = snap['revision']
        snap_dict['devmode'] = snap['devmode']
        snap_dict['install-date'] = snap['install-date']
        snap_dict['name'] = snap['name']
        snap_dict['status'] = INSTALLED
        if(snap['type'] == "os" or snap['type'] == "core" or snap['type'] == "kernel"):
            msg_system.append(snap_dict)
        elif(snap['type'] == "app" and snap['name'] in system_snap_list):
            msg_system.append(snap_dict)
        else:
            msg_user.append(snap_dict)

    save_to_firestore('thingpoint_db',msg_system,tpid,"system_snap_list")
    save_to_firestore('thingpoint_db',msg_user,tpid,"user_snap_list")
    send_pushsnap_req(tpid, "install")


def update_thingpointdb(thingpoint,dal_obj,snap_name,snap_status,kind=None,message=None):
    user_snap_list = thingpoint['user_snap_list']
    serial = thingpoint['serial']
    for n,snap in enumerate(user_snap_list):
        if snap["name"] == snap_name:
            if snap["status"] == DELETING and snap_status == INSTALLED :
                print("inside the deleting check")
                user_snap_list.pop(n)    
            else:
                print("inside the else deleting check")
                snap["status"] = snap_status

            if kind:
                if (kind == "snap-already-installed"):
                    #do not update the count
                    snap["kind"] = kind
                    snap["status"] = INSTALLED
            if message:
                snap["message"] = message

            print("[DEBUG]:updated snap status:{}".format(user_snap_list))
            dal_obj.update(user_snap_list,serial,'user_snap_list')
            return

    system_snap_list = thingpoint['system_snap_list']
    serial = thingpoint['serial']
    for n,snap in enumerate(system_snap_list):
        if snap["name"] == snap_name:
            if snap["status"] == DELETING and snap_status == INSTALLED :
                user_snap_list.pop(n)    
            else:
                snap["status"] = snap_status

            if kind:
                if (kind != "snap-already-installed"):
                    #do not update the count
                    snap["kind"] = kind
                    snap["status"] = INSTALLED
            if message:
                snap["message"] = message

            print("updated snap status:{}".format(system_snap_list))
            dal_obj.update(system_snap_list,serial,'system_snap_list')
            return
    return


def pushsnapresp_handler(message):
    #parse registration message and reply with pushsnapresp_handler message
    print("starting pushsnapresp_handler")
    tpid = message['tpid']
    timestamp = message['timestamp']
    hostname = message['hostname']
    responselist = message['response']
    dal_obj = DataAccessLayer("thingpoint_db")
    thingpoint = dal_obj.get(tpid)
    for response in responselist:
        snap_status = INSTALLED
        type = response['type']
        status = response['status']
        snap_name = response['snap_name']
        if (type == "error"):
            print("type is error")
            result = response['result']
            if result:
                kind = result['kind']
                message = result['message']
                snap_status = FAILED
                print("[DEBUG]: updating status Failed for snap:",snap_name)
                update_thingpointdb(thingpoint,dal_obj,snap_name,snap_status,kind,message)
        elif(status == "Accepted"):
            print("status is error")
            update_thingpointdb(thingpoint,dal_obj,snap_name,snap_status)
        else:
            print("type or status not handled currently")
    return

def snaplistupdate_thingpointdb(thingpoint,dal_obj,snap):
    user_snap_list = thingpoint['user_snap_list']
    serial = thingpoint['serial']
    for n,user_snap in enumerate(user_snap_list):
        if user_snap["name"] == snap["name"]:
            #snap_dict = {}
            user_snap['id'] = snap['id']
            user_snap['installed-size'] = snap['installed-size']
            user_snap['type'] = snap['type']
            user_snap['version'] = snap['version']
            user_snap['channel'] = snap['channel']
            user_snap['revision'] = snap['revision']
            user_snap['devmode'] = snap['devmode']
            user_snap['install-date'] = snap['install-date']
            user_snap['name'] = snap['name']
            user_snap['status'] = INSTALLED
            #user_snap_list[n] = snap_dict
            print("updated snap status:{}".format(user_snap_list))
            dal_obj.update(user_snap_list,serial,'user_snap_list')
            return

    system_snap_list = thingpoint['system_snap_list']
    serial = thingpoint['serial']
    for n,system_snap in enumerate(system_snap_list):
        if system_snap["name"] == snap["name"]:
            #snap_dict = {}
            system_snap['id'] = snap['id']
            system_snap['installed-size'] = snap['installed-size']
            system_snap['type'] = snap['type']
            system_snap['version'] = snap['version']
            system_snap['channel'] = snap['channel']
            system_snap['revision'] = snap['revision']
            system_snap['devmode'] = snap['devmode']
            system_snap['install-date'] = snap['install-date']
            system_snap['name'] = snap['name']
            system_snap['status'] = INSTALLED
            #user_snap_list[n] = snap_dict
            print("updated snap status:{}".format(system_snap_list))
            dal_obj.update(system_snap_list,serial,'system_snap_list')
            return

    return

def snapupdatedlist_handler(message):
    #parse registration message and reply with updatesnapinfo_handler message
    #parse registration message and reply Pushsnapreg message
    print("starting updatedsnaplist_handler")
    tpid = message['tpid']
    timestamp = message['timestamp']
    hostname = message['hostname']
    snaplist = message['snaplist']
    print("snaplist: {}".format(snaplist))
    dal_obj = DataAccessLayer("thingpoint_db")
    thingpoint = dal_obj.get(tpid)
    msg_system = []
    msg_user = []
    for snap in snaplist:
        snaplistupdate_thingpointdb(thingpoint,dal_obj,snap)
    return

def useraction_handler(message):
    print("useraction:{}".format(message))
    snap_name = message['snap_name']
    action = message['action']
    tpid = message['tpid']
    send_pushsnap_req(tpid,action,snap_name)
    return

def thing_healthmon_handler(message):
    msg_dict = {}
    serial = message["tpid"].strip()
    
    msg_dict["totalmem"] = message["totalmem"]
    msg_dict["freemem"] = message["freemem"]
    msg_dict["timestamp"] = message["timestamp"]
    msg_dict["cpu_usage"] = message["cpu_usage"]
    collection = "thingpoint_"+serial
    save_to_firestore(collection,msg_dict)

def presence_status_handler(message):
    if "tpid" in message.keys():
        tpid = message["tpid"].strip()
        conn_status = message["status"]
        save_to_firestore('thingpoint_db',conn_status,tpid,"conn_status")
    return

def deviceinfo_handler(message):
    tpid = message["tpid"].strip()
    network_details = message["networkdetails"]
    mac = network_details["eth0"][0]["mac"]
    print("tpid:{}, mac:{}".format(tpid,mac))
    save_to_firestore('thingpoint_db',mac,tpid,"mac")

iot_mgmt_cloud_handler_map = {
    "dscmgr/registration": {
        'handler': registration_handler
    },
    "dscmgr/snaplist":{
        'handler': snaplist_handler
    },
    "dscmgr/pushsnapresp":{
        'handler': pushsnapresp_handler
    },
    "dscmgr/snapupdatedlist":{
        'handler': snapupdatedlist_handler
    },
    "user/action":{
        'handler': useraction_handler
    },
    "iot-gw/healthmon/devicemon":{
        'handler': thing_healthmon_handler
    },
    "presence/status":{
        'handler': presence_status_handler
    },
    "iot-gw/healthmon/deviceinfo":{
        'handler': deviceinfo_handler
    }
}


def handler(request):
    """Responds to any HTTP request.
    Args:
        request (flask.Request): HTTP request object.
    Returns:
        The response text or any set of values that can be turned into a
        Response object using
        `make_response <http://flask.pocoo.org/docs/1.0/api/#flask.Flask.make_response>`.
    """
    request_json = request.get_json()
    request_args = request.args
    message = None
    print("request object : {}".format(dir(request)))
    
    print("request:{}".format(json.dumps(request_json)))
    
    if request_json and 'message' in request_json:
        message = request_json['message']
        msg_handler = iot_mgmt_cloud_handler_map.get(message,{}).get('handler',None)
        if msg_handler:
            msg_handler(request_json)
        else:
            print("ERROR: message handler not defined")
    else:
        print("ERROR: handler request body does not have message key")
    
    
    

    #return 'Hello {}!'.format(escape(name))
    return 
